*
*	MicroVAX version of 4010/4014 subroutines.  July, 1986
*
*
*					SUBROUTINE  A1OUT
*
	SUBROUTINE A1OUT( NCHAR, IA1 )
	DIMENSION IADE(768), IA1(*)
	ITEMP = NCHAR
	DO 10 I=1,NCHAR,768
	  ISEND = 768
	  IF( ITEMP .LT. 768 ) ISEND = ITEMP
	  CALL KA12AS( ISEND, IA1(I), IADE )
	  CALL ANSTR( ISEND, IADE )
	  ITEMP = ITEMP - 768
   10	CONTINUE
	RETURN
	END
C
C					SUBROUTINE  AOUTST
C
	SUBROUTINE AOUTST( NCHAR, IAM )
	DIMENSION IADE(768), IAM(*)
	DATA MAXLEN / 768 /
	LEN = NCHAR
	IF( LEN .GT. MAXLEN ) LEN = MAXLEN
	CALL KAM2AS( LEN, IAM, IADE )
	CALL ANSTR( LEN, IADE )
	RETURN
	END
C
C					SUBROUTINE  BUFFPK
C
	SUBROUTINE BUFFPK( NCHAR, IOUT )
	include 'pcplot.inc'
	DIMENSION IDATA(768), IOUT(*), ISYNC(5)
	DATA MAXLEN, LENOUT, NODATA / 768, 0, 1 /
	DATA ITEMP / 0 /, ISYNC(1), ISYNC(2), ISYNC(3), ISYNC(4),
     .			  ISYNC(5) / 5*22 /
	common /buffpk_keep/idata
c
c hee,hee... assumed that idata was static... added  buffpk_keep
c to make it so.
c
	ITRAIL = KTRAIL
	LEN    = NCHAR
	KOTLFT = MAXLEN - LENOUT - KTRAIL
*	DUMP THE BUFFER IF THE MODE IS UNBUFFERED
	IF( KUNIT .EQ. 4 ) GO TO 45
*	DUMP THE BUFFER WHEN REQUESTED BY LEN=0
	IF( NCHAR .LE. 0 ) GO TO 10
*	DON'T DUMP THE BUFFER IF NEW STRING WILL FIT
	KSYNCS = KPADV
	ISETBK = 0
	NCH = NCHAR-1
	IF( IOUT(1) .GT. 31 ) ISETBK = MIN0( ITEMP, NCH )
	IMAXL = KSYNCS + NCHAR - ISETBK
	IF( IMAXL .LE. KOTLFT ) GO TO 70
*	DETERMINE IF THERE IS DATA IN BUFFER
   10	IF( NODATA .EQ. 1 ) GO TO 50
	NODATA = 1
*	DETERMINE THE FORMAT THE USER WANTS BUFFER DUMPED IN
	GO TO ( 20, 30, 40, 45 ) , KUNIT
*	OUTPUT BUFFER FORMAT IS (GS),PLTCHRS,DATA,(US)
*	APPEND (US) TO END OF BUFFER
   20	LENOUT = LENOUT + 1
	IDATA( LENOUT ) = 31
	CALL ADEOUT( LENOUT, IDATA )
*	RESTORE THE BEAM POSITION AT FIRST OF THE NEXT BUFFER
	ISUB = 1
	IF( KTERM .GE. 3 ) ISUB = 2
	CALL PLTCHR( KBEAMX, KBEAMY, IDATA(ISUB) )
	IDATA(2) = IDATA(ISUB)
	LENOUT   = 5+ISUB
	IDATA(1) = 29
*	AND NOW THE MODE BEFORE THE OUTPUT WAS ASKED FOR
	DO 19 I=2,KPAD2
	  IDATA(LENOUT) = 22
	  LENOUT = LENOUT + 1
   19	CONTINUE
	KEY = KKMODE + 1
	IF( KEY .LT. 1 ) KEY = 1
	IF( KEY .GT. 5 ) KEY = 1
*	MODE IS A/N, VEC, PNT, INC, DSH
	GO TO (  21,  22,  23,  24,  22 ) , KEY
*	ENTER A/N MODE
   21	IDATA(LENOUT) = 31
	GO TO 50
*	IF READY FOR A MOVE, THEN REMOVE FIXUP CHARS
   22	IF( KMOVEF .EQ. 1 ) LENOUT = 2
	LENOUT = LENOUT - 1
*	CHECK IF DASHED LINE OR Z AXIS MUST BE RESTORED
	IF( KLINE .EQ. 0 .AND. KZAXIS .EQ. 0 ) GO TO 50
	IDATA(LENOUT+1) = 27
	LENOUT = LENOUT + 2
	IDATA(LENOUT)   = 96 + KZAXIS*8 + KLINE
	GO TO 50
*	ENTER POINT MODE
   23	IF( KTERM .LT. 3 ) GO TO 22
	IDATA( LENOUT ) = 28
	LENOUT = LENOUT + 1
	GO TO 22
*	ENTER INCREMENTAL PLOT MODE
   24	IDATA(LENOUT) = 30
*	RAISE OR LOWER PEN AS NEEDED
*	THE FOLLOWING 3 LINES ARE NOT NEEDED ON SOME PLOTTERS **************
	LENOUT = LENOUT + 1
	IDATA( LENOUT ) = 80
	IF( KMOVEF .EQ. 1 ) IDATA(LENOUT) = 32
**********************************************************************
	GO TO 50
*	OUTPUT BUFFER FORMAT IS (SYN),DATA,(ESC)
   30	IF( NCHAR .LE. 0 .AND. KGNMOD .NE. 1 ) GO TO 20
	LENOUT = LENOUT+1
*	APPEND (ESC) TO END OF BUFFER
	IDATA(LENOUT) = 27
	CALL ADEOUT( LENOUT, IDATA )
	IDATA(1) = 22
	LENOUT = 1
	GO TO 50
*	OUTPUT BUFFER FORMAT IS DATA ONLY
   40	CALL ADEOUT( LENOUT, IDATA )
	LENOUT = 0
	GO TO 50
*	NON-BUFFERED OUTPUT FORMAT
   45	IF( LENOUT .GT. 0 ) CALL ADEOUT( LENOUT, IDATA )
	IF( LEN .GT. 0 ) CALL ADEOUT( LEN, IOUT )
	IF( KPADV .GT. 0 ) CALL ADEOUT( KPADV, ISYNC )
	KPADV  = 0
	LENOUT = 0
	NODATA = 1
	GO TO 90
*
*	Where we go after buffered output.
*
   50	KOTLFT = MAXLEN-LENOUT-ITRAIL
	ITEMP  = 0
	ISETBK = 0
	KPADV  = 0
	do 1200 ilcd = 1 , 1000
          kpadv = kpadv + ilcd
 1200	continue
	kpadv = kpadv*isetbk
	IF( LEN .LE. 0 ) GO TO 90
   70	NODATA = 0
	LENOUT = LENOUT-ISETBK
	KOTLFT = KOTLFT+ISETBK
	IF( LEN .GT. KOTLFT ) LEN = KOTLFT
	DO 80 I=1,LEN
	  LENOUT = LENOUT+1
	  IDATA(LENOUT)=IOUT(I)
   80	CONTINUE
	ITEMP = KSYNCS
	KPADV = 0
	IF( ITEMP .LE. 0 ) GO TO 90
	DO 85 I=1,ITEMP
	  LENOUT = LENOUT + 1
	  IDATA(LENOUT) = 22
   85	CONTINUE
   90	KOTLFT = MAXLEN-LENOUT-ITRAIL
	RETURN
	END
C
C					SUBROUTINE  FLUSH1
C
	SUBROUTINE FLUSH1( NCHAR, IOUT )
	include 'pcplot.inc'
	DIMENSION IDATA(768), IOUT(*), ISYNC(5)
	DATA MAXLEN,LENOUT,NODATA/768,0,1/
      DATA ITEMP/0/,ISYNC(1),ISYNC(2),ISYNC(3),ISYNC(4),ISYNC(5)/5*22/
      ITRAIL=KTRAIL
      LEN=NCHAR
      KOTLFT=MAXLEN-LENOUT-KTRAIL
C * DUMP THE BUFFER IF THE MODE IS UNBUFFERED
      IF(KUNIT .EQ. 4)GO TO 45
      KSYNCS=KPADV
      ISETBK=0
      IMAXL=KSYNCS+NCHAR-ISETBK
C
C	THE MAJOR BETWEEN THIS ROUTINE AND BUFFPK IS THAT THE NEXT LINE
C        IS COMMENTED OUT.
C

C      IF(IMAXL .LE. KOTLFT)GO TO 70

C * DETERMINE IF THERE IS DATA IN BUFFER
10    IF(NODATA .EQ. 1)GO TO 50
      NODATA=1
C * DETERMINE THE FORMAT THE USER WANTS BUFFER DUMPED IN
      GO TO (20,30,40,45),KUNIT
C * OUTPUT BUFFER FORMAT IS (GS),PLTCHRS,DATA,(US)
20    LENOUT=LENOUT+1
C * APPEND (US) TO END OF BUFFER
      IDATA(LENOUT)=31
      CALL ADEOUT(LENOUT,IDATA)
C * RESTORE THE BEAM POSITION AT FIRST OF THE NEXT BUFFER
      ISUB=1
      IF(KTERM .GE. 3) ISUB=2
      CALL PLTCHR(KBEAMX,KBEAMY,IDATA(ISUB))
      IDATA(2)=IDATA(ISUB)
      LENOUT=5+ISUB
      IDATA(1)=29
C * AND NOW THE MODE BEFORE THE OUTPUT WAS ASKED FOR
      DO 19 I=2,KPAD2
      IDATA(LENOUT)=22
19    LENOUT=LENOUT+1
      KEY=KKMODE+1
      IF(KEY .LT. 1)KEY=1
      IF(KEY .GT. 5)KEY=1
C * MODE IS A/N,VEC,PNT,INC,DSH
      GO TO (21, 22, 23, 24, 22),KEY
C * ENTER A/N MODE
21    IDATA(LENOUT)=31
      GO TO 50
C * IF READY FOR A MOVE, THEN REMOVE FIXUP CHARS
22    IF(KMOVEF .EQ. 1) LENOUT=2
      LENOUT=LENOUT-1
C * CHECK IF DASHED LINE OR Z AXIS MUST BE RESTORED
      IF(KLINE .EQ. 0 .AND. KZAXIS .EQ. 0) GO TO 50
      IDATA(LENOUT+1)=27
      LENOUT=LENOUT+2
      IDATA(LENOUT)=96+KZAXIS*8+KLINE
      GO TO 50
C * ENTER POINT MODE
23    IF(KTERM .LT. 3)GO TO 22
      IDATA(LENOUT)=28
      LENOUT=LENOUT+1
      GO TO 22
C * ENTER INCREMENTAL PLOT MODE
24    IDATA(LENOUT)=30
C * RAISE OR LOWER PEN AS NEEDED
C * THE FOLLOWING 3 LINES ARE NOT NEEDED ON SOME PLOTTERS **************
      LENOUT=LENOUT+1
      IDATA(LENOUT)=80
      IF(KMOVEF .EQ. 1)IDATA(LENOUT)=32
C **********************************************************************
      GO TO 50
C * OUTPUT BUFFER FORMAT IS (SYN),DATA,(ESC)
30    IF(NCHAR .LE. 0 .AND. KGNMOD .NE. 1)GO TO 20
      LENOUT=LENOUT+1
C * APPEND (ESC) TO END OF BUFFER
      IDATA(LENOUT)=27
      CALL ADEOUT(LENOUT,IDATA)
      IDATA(1)=22
      LENOUT=1
      GO TO 50
C * OUTPUT BUFFER FORMAT IS DATA ONLY
40    CALL ADEOUT(LENOUT,IDATA)
      LENOUT=0
      GO TO 50
C * NON-BUFFERED OUTPUT FORMAT
45    IF(LENOUT .GT. 0)CALL ADEOUT(LENOUT,IDATA)
      IF(LEN .GT. 0)CALL ADEOUT(LEN,IOUT)
      IF(KPADV .GT. 0)CALL ADEOUT(KPADV,ISYNC)
      KPADV=0
      LENOUT=0
      NODATA=1
      GO TO 90
50    KOTLFT=MAXLEN-LENOUT-ITRAIL
      ITEMP=0
      ISETBK=0
      KPADV=0
      IF(LEN .LE. 0) GO TO 90
70    NODATA=0
      LENOUT=LENOUT-ISETBK
      KOTLFT=KOTLFT+ISETBK
      IF(LEN .GT. KOTLFT)LEN=KOTLFT
      DO 80 I=1,LEN
      LENOUT=LENOUT+1
80    IDATA(LENOUT)=IOUT(I)
      ITEMP=KSYNCS
      KPADV=0
      IF(ITEMP .LE. 0) GO TO 90
      DO 85 I=1,ITEMP
      LENOUT = LENOUT+1
85    IDATA(LENOUT) = 22
90    KOTLFT=MAXLEN-LENOUT-ITRAIL
      RETURN
      END
C
C					SUBROUTINE  INITT
C
      SUBROUTINE INITT( IBAUD )
	include 'pcplot.inc'
	KBAUDR = IBAUD
	KPAD2  = KBAUDR/308 + 1
	KGNMOD = 0
	KPADV  = 0
	KOBLEN = 72
	KLEVEL = 0
	KTERM  = 1
	KFACTR = 4
C	Set the Output buffer format
	CALL SETBUF( 1 )
	KINLFT = 0
	KOTLFT = 1
	CALL RESET
	CALL NEWPAG
	RETURN
	END
C *
C *					Subroutine  FINITT
C *
      SUBROUTINE FINITT( IX, IY )
      CALL MOVABS(IX,IY)
      CALL ALFMOD
      CALL TSEND
      LSTOP=0
      IF (LSTOP .NE. 0) GOTO 10
      CALL EXIT
10    RETURN
      END
C
C					SUBROUTINE  TCSLEV
C
	SUBROUTINE TCSLEV( LEVEL )
C *	TCSLEV RETURNS THE LEVEL AND THE LAST MODIFICATION DATE OF THE
C *	SOFTWARE. IT SHOULD BE UPDATED WHENEVER A MODIFICATION IS MADE.
	DIMENSION LEVEL( 3 )
C *	LEVEL (1) IS THE YEAR OF LAST MODIFICATION
C *	LEVEL (2) IS THE DAY OF LAST MODIFICATION - July, 1986
C *	LEVEL (3) IS THE LEVEL NUMBER
	LEVEL(1) = 86
	LEVEL(2) = 200
	LEVEL(3) = 1
	RETURN
	END
C *
C *	The subroutines above are machine dependent.
C * 
C *	The subroutines below are not machine dependent. 
C *
C *
C *					SUBROUTINE  ANMODE
C *
      SUBROUTINE ANMODE
	include 'pcplot.inc'
C *	ENTER ALPHA-NUMERIC MODE
      IF(KTERM.LT.3) GO TO 10
      KLINE=0
      KZAXIS=0
      call tsend
      CALL CWSEND
10    call tsend
      CALL ALFMOD
C	DUMP THE OUTPUT BUFFER
      CALL TSEND
      RETURN
      END
C
C					SUBROUTINE  SEEMRG
C
	SUBROUTINE SEEMRG( MLEFT, MRIGHT )
	include 'pcplot.inc'
	MLEFT  = KLMRGN
	MRIGHT = KRMRGN
	RETURN
	END
C
C					SUBROUTINE  SEETRM
C
      SUBROUTINE SEETRM( IBAUDR, ITERM, ICSIZE, MAXSCR )
	include 'pcplot.inc'
      IBAUDR=KBAUDR
      ITERM=KTERM
      ICSIZE=KSIZEF
      MAXSCR=4095/KFACTR
      RETURN
      END
C
C					SUBROUTINE  SEETW
C
      SUBROUTINE SEETW( MINX, MAXX, MINY, MAXY )
	include 'pcplot.inc'
      MINX=KMINSX
      MAXX=KMAXSX
      MINY=KMINSY
      MAXY=KMAXSY
      RETURN
      END
C
C					SUBROUTINE  SEEDW
C
      SUBROUTINE SEEDW( XMIN, XMAX, YMIN, YMAX )
	include 'pcplot.inc'
      XMIN=TMINVX
      XMAX=TMAXVX
      YMIN=TMINVY
      YMAX=TMAXVY
      RETURN
      END
C
C					subroutine  SEEMOD
C
      SUBROUTINE SEEMOD( LINE, IZAXIS, MODE )
	include 'pcplot.inc'
      LINE=KLINE
      IZAXIS=KZAXIS
      MODE=KKMODE
      RETURN
      END
C
C					subroutine  SEETRN
C
      SUBROUTINE SEETRN( XFAC, YFAC, KEY )
	include 'pcplot.inc'
      XFAC=TRFACX
      YFAC=TRFACY
      KEY=KEYCON
      RETURN
      END
C
C					subroutine  SEEREL
C
      SUBROUTINE SEEREL( RCOS, RSIN, SCALE )
	include 'pcplot.inc'
      RCOS=TRCOSF
      RSIN=TRSINF
      SCALE=TRSCAL
      RETURN
      END
C
C					subroutine  TTBLSZ
C
      SUBROUTINE TTBLSZ( ITBLSZ )
	include 'pcplot.inc'
      KTBLSZ=ITBLSZ
      RETURN
      END
C
C					subroutine  TERM
C
	SUBROUTINE TERM( ITERM, ISCAL )
*
*	This routine is called by the user to set up the terminal type.
*	The terminal emulation program on the PC is set up for a 
*	Tektronix 4010 terminal.  That means we want to set it up as
*	terminal type 1.
*
	include 'pcplot.inc'
	kterm  = iterm
	kfactr = 4
	if( iscal .gt. 1024 ) kfactr = 1
	call reset
	return
	end
C
C					subroutine  DASHSR
C
      SUBROUTINE DASHSR( X, Y, L )
      CALL REL2AB(X,Y,RX,RY)
      CALL DASHSA(RX,RY,L)
      RETURN
      END
C
C					subroutine  DASHSA
C
      SUBROUTINE DASHSA( X, Y, L )
	include 'pcplot.inc'
      CALL LVLCHT
      XOLD=TIMAGX
      YOLD=TIMAGY
      KEY=KEYCON
      IF(KEYCON .LT. 1)KEY=5
      IF(KEYCON .GT. 4)KEY=4
C * LINEAR LOG POLAR USER ERROR
      GO TO (100, 100, 200, 400, 100),KEY
C * ERROR LINEAR LOG
100   CALL DASHA(X,Y,L)
      XOLD=X
      YOLD=Y
      RETURN
C * POLAR
200   DX=X-XOLD
      DY=Y-YOLD
      YSTEP=SIGN(5.0/TRFACY,DY)
      IF(ABS(DY*.75) .LE. ABS(YSTEP)) GO TO 100
      FRAC=DX/DY
      NSEG=(DY/YSTEP)+.9999
      YOUT=YOLD
300   IF(NSEG .LT. 2) GO TO 100
      YOUT=YOUT+YSTEP
      XOUT=XOLD+(YOUT-YOLD)*FRAC
      CALL DASHA(XOUT,YOUT,L)
      NSEG=NSEG-1
      GO TO 300
C * USER SEGMENTATION
400   CONTINUE
C      CALL USDASH(X,Y,L)
      GO TO 100
      END
C
C					subroutine  DRAWSR
C
      SUBROUTINE DRAWSR( X, Y )
      CALL REL2AB(X,Y,RX,RY)
      CALL DRAWSA(RX,RY)
      RETURN
      END
C
C					subroutine  DRAWSA
C
      SUBROUTINE DRAWSA( X, Y )
	include 'pcplot.inc'
      CALL LVLCHT
      XOLD=TIMAGX
      YOLD=TIMAGY
      KEY=KEYCON
      IF(KEYCON .LT. 1)KEY=5
      IF(KEYCON .GT. 4)KEY=4
C * LINEAR LOG POLAR USER ERROR
      GO TO (100, 100, 200, 400, 100),KEY
C * ERROR LINEAR LOG
100   CALL DRAWA(X,Y)
      XOLD=X
      YOLD=Y
      RETURN
C * POLAR
200   DX=X-XOLD
      DY=Y-YOLD
      YSTEP=SIGN(5.0/TRFACY,DY)
      IF(ABS(DY*.75) .LE. ABS(YSTEP)) GO TO 100
      FRAC=DX/DY
      NSEG=(DY/YSTEP)+.9999
      YOUT=YOLD
300   IF(NSEG .LT. 2) GO TO 100
      YOUT=YOUT+YSTEP
      XOUT=XOLD+(YOUT-YOLD)*FRAC
      CALL DRAWA(XOUT,YOUT)
      NSEG=NSEG-1
      GO TO 300
C * USER SEGMENTATION
400   CONTINUE
C      CALL USDRAW(X,Y)
      GO TO 100
      END
C
C					subroutine  INCPLT
C
      SUBROUTINE INCPLT( IONOFF, IDIR, NO )
      DIMENSION IPLTBL(8),KBMUP(10)
	include 'pcplot.inc'
      DATA IPLTBL(1),IPLTBL(2),IPLTBL(3),IPLTBL(4)/4,5,1,9/
      DATA IPLTBL(5),IPLTBL(6),IPLTBL(7),IPLTBL(8)/8,10,2,6/
      DATA KBMUP(1),KBMUP(2),KBMUP(3),KBMUP(4),KBMUP(5)/0,1,1,1,0/
      DATA KBMUP(6),KBMUP(7),KBMUP(8),KBMUP(9),KBMUP(10)/-1,-1,-1,0,1/
      IF(KKMODE .NE. 3)CALL IPMOD
      IPEN=32+IONOFF*48
C * THIS SECTION TO ACCOMMODATE PLOTTERS REQUIRING A SEPARATE PEN
C * CHARACTER -- IT MAY BE OMITTED IF NOT NEEDED ***********************
      CALL TOUTPT(IPEN)
      IPEN=64
C **********************************************************************
      KMOVEF=IABS(IONOFF-1)
      NDXPLT=MOD(IDIR,8)+1
      IPLTCH=IPLTBL(NDXPLT)+IPEN
      KBMUPX=KBMUP(NDXPLT)
      KBMUPY=KBMUP(NDXPLT+2)
      DO 10 I=1,NO
      CALL TOUTPT(IPLTCH)
      KBEAMX=KBEAMX+KBMUPX
10    KBEAMY=KBEAMY+KBMUPY
      RETURN
      END
C
C					subroutine  RROTAT
C
      SUBROUTINE RROTAT( DEG )
	include 'pcplot.inc'
      TRSINF=SIN(DEG/57.29578)
      TRCOSF=COS(DEG/57.29578)
      RETURN
      END
C
C					subroutine  RSCALE
C
      SUBROUTINE RSCALE( FACTOR )
	include 'pcplot.inc'
      TRSCAL=FACTOR
      RETURN
      END
C
C					subroutine  BELL
C
      SUBROUTINE BELL
	include 'pcplot.inc'
C *  OUTPUT (BEL)
      CALL TOUTPT(7)
      CALL IOWIAT(1)
C * BELL NULLIFIES MOVE AT TERMINAL
      KMOVEF=0
      RETURN
      END
C
C					subroutine  VWINDO
C
      SUBROUTINE VWINDO( XMIN, XRANGE, YMIN, YRANGE )
	include 'pcplot.inc'
C * DEFINE VIRTUAL WINDOW IN TERMINAL COMMON AREA
      TMINVX=XMIN
      TMAXVX=XMIN+XRANGE
      TMINVY=YMIN
      TMAXVY=YMIN+YRANGE
      CALL RESCAL
      RETURN
      END
C
C					subroutine  SWINDO
C
      SUBROUTINE SWINDO( MINX, LENX, MINY, LENY )
	include 'pcplot.inc'
C * DEFINE SCREEN WINDOW IN TERMINAL COMMON AREA
      KMINSX=MINX
      KMAXSX=MINX+LENX
      KMINSY=MINY
      KMAXSY=MINY+LENY
      CALL RESCAL
      RETURN
      END
C
C					subroutine  TWINDO
C
	subroutine twindo( MINX, MAXX, MINY, MAXY )
	include 'pcplot.inc'
*
*	Define that terminal window by setting values in the common area.
*
	kminsx = minx
	kmaxsx = maxx
	kminsy = miny
	kmaxsy = maxy
	call rescal		
c	Setup the rescaling factors
	return
	end
C
C					subroutine  DWINDO
C
	subroutine dwindo( XMIN, XMAX, YMIN, YMAX )
	include 'pcplot.inc'
*
*	define the data window by setting values in the common area.
*
	tminvx = xmin
	tmaxvx = xmax
	tminvy = ymin
	tmaxvy = ymax
	call rescal
	return
	end
C
C					subroutine  POINTR
C
      SUBROUTINE POINTR( X, Y )
      CALL REL2AB(X,Y,RX,RY)
      CALL POINTA(RX,RY)
      RETURN
      END
C
C					subroutine  DASHR
C
      SUBROUTINE DASHR( X, Y, L )
      CALL REL2AB(X,Y,XL,YL)
      CALL DASHA(XL,YL,L)
      RETURN
      END
C
C					subroutine  DASHA
C
      SUBROUTINE DASHA( X, Y, L )
	include 'pcplot.inc'
      CALL LVLCHT
C * CONVERT TO SCREEN CO-ORDINATES
      CALL V2ST(1,X,Y,IX,IY)
C * SKIP IF LINE COMPLETELY OUTSIDE WINDOW
      IF(KGNFLG .EQ. 1)GO TO 10
      CALL DSHMOD(L)
      CALL TKDASH(IX,IY)
10    RETURN
      END
C
C					subroutine  DSHREL
C
      SUBROUTINE DSHREL( IX, IY, L )
	include 'pcplot.inc'
      JX=IX+KBEAMX
      JY=IY+KBEAMY
      CALL DSHABS(JX,JY,L)
      RETURN
      END
C
C					subroutine  DSHABS
C
      SUBROUTINE DSHABS( IX, IY, L )
	include 'pcplot.inc'
      CALL DSHMOD(L)
      CALL TKDASH(IX,IY)
C * SET THE GRAPHIC LEVEL FLAG TO SCREEN
      KGRAFL=0
      RETURN
      END
C
C					subroutine  DRAWR
C
      SUBROUTINE DRAWR( X, Y )
      CALL REL2AB(X,Y,RX,RY)
      CALL DRAWA(RX,RY)
      RETURN
      END
C
C					subroutine  POINTA
C
      SUBROUTINE POINTA( X, Y )
	include 'pcplot.inc'
      CALL LVLCHT
C * CONVERT TO SCREEN CO-ORDINATES
      CALL V2ST(0,X,Y,IX,IY)
C * SKIP IF LINE COMPLETELY OUTSIDE WINDOW
      IF(KGNFLG .EQ. 1)GO TO 10
      IF(KKMODE .NE. 2)CALL PNTMOD
      CALL TKPNT(IX,IY)
10    RETURN
      END
C
C					subroutine  DRAWA
C
      SUBROUTINE DRAWA( X, Y )
	include 'pcplot.inc'
C * SET TERMINAL TO DRAW SOLID LINES IF NEEDED
C * THIS SECTION IS NEEDED FOR 4014 ENHANCED ***************************
      IF(KLINE .EQ. 0)GO TO 5
      KLINE=0
      CALL CWSEND
5     CONTINUE
C **********************************************************************
      CALL LVLCHT
C * CONVERT TO SCREEN CO-ORDINATES
      CALL V2ST(1,X,Y,IX,IY)
C * SKIP IF LINE COMPLETELY OUTSIDE WINDOW
      IF(KGNFLG .EQ. 1)GO TO 10
      IF(KKMODE.NE.1)CALL VECMOD
      IF(KMOVEF.EQ.1)CALL XYCNVT(KBEAMX,KBEAMY)
      CALL XYCNVT(IX,IY)
10    RETURN
      END
C
C					subroutine  MOVER
C
      SUBROUTINE MOVER( X, Y )
      CALL REL2AB(X,Y,RX,RY)
      CALL MOVEA(RX,RY)
      RETURN
      END
C
C					subroutine  REL2AB
C
      SUBROUTINE REL2AB( XIN, YIN, XOUT, YOUT )
	include 'pcplot.inc'
      CALL LVLCHT
      XOUT=(((XIN*TRCOSF)-(YIN*TRSINF))*TRSCAL)+TIMAGX
      YOUT=(((XIN*TRSINF)+(YIN*TRCOSF))*TRSCAL)+TIMAGY
      RETURN
      END
C
C					subroutine  MOVEA
C
      SUBROUTINE MOVEA( X, Y )
	include 'pcplot.inc'
      CALL LVLCHT
C * CONVERT TO SCREEN CO-ORDINATES
      CALL V2ST(0,X,Y,IX,IY)
C * SKIP IF LINE COMPLETELY OUTSIDE WINDOW
      IF(KGNFLG .EQ. 1)GO TO 10
      CALL VECMOD
      CALL XYCNVT(IX,IY)
10    RETURN
      END
C
C					subroutine  VCURSR
C
      SUBROUTINE VCURSR( ICHAR, X, Y )
      CALL SCURSR(ICHAR,IXA,IYA)
      CALL REVCOT(IXA,IYA,X,Y)
      RETURN
      END
C
C					subroutine  V2ST
C
      SUBROUTINE V2ST( I, X, Y, IX, IY )
      DIMENSION BUFIN(4),BFOUT(4)
	include 'pcplot.inc'
      EQUIVALENCE (BUFIN(1),XS),(BUFIN(2),YS),(BUFIN(3),XE),
     1(BUFIN(4),YE)
      EQUIVALENCE (BFOUT(1),CXS),(BFOUT(2),CYS),(BFOUT(3),CXE),
     1            (BFOUT(4),CYE)
	XE = X
	YE = Y
*	POINT OR MOVE
	IF( I .EQ. 0 ) GO TO 10
*
*	BRIGHT VECTOR  ( all options other than point and move).
*
	XS = TIMAGX
	YS = TIMAGY
	CALL CLIPT( BUFIN, BFOUT )	
cQZ	Clip Vector
*
*	KGNFLG = 0 means point is on screen.  KGNFLG means point is off screen.
*
	IF( KGNFLG .EQ. 1 ) GO TO 110
*	Are we at the start point?
	IF( CXS .EQ. TREALX .AND. CYS .EQ. TREALY ) GO TO 120
*	Move Beam to the starting point.
	MODE = KKMODE
	CALL VECMOD
	CALL WINCOT( CXS, CYS, IX, IY )
	CALL XYCNVT( IX, IY )
	KKMODE = MODE
	GO TO 120
   10	CONTINUE
	CALL PCLIPT( XE,YE )		
c	For point or move.
	IF( KGNFLG .EQ. 1 ) GO TO 110	
c	Check to see if point is off screen
	CXE = XE
	CYE = YE
  120	CALL WINCOT( CXE, CYE, IX, IY )	
c	Convert data to screen coordinates.
*
*	Save positions Absolute and Imaginary
*
	TREALX = CXE
	TREALY = CYE
  110	TIMAGX = X
	TIMAGY = Y
	RETURN
	END
C
C					subroutine  CLIPT
C
      SUBROUTINE CLIPT( BUFIN, OUTBF )
      DIMENSION  BUFIN(*),OUTBF(*)
	include 'pcplot.inc'
      GSTAX=BUFIN(1)
      GSTAY=BUFIN(2)
      GENDX=BUFIN(3)
      GENDY=BUFIN(4)
      IF(GSTAX.GE.TMINVX)GO TO 10
      IF(GENDX.GE.TMINVX)GO TO 20
      GO TO 110
10    IF(GSTAX.LE.TMAXVX)GO TO 20
      IF(GENDX.LE.TMAXVX)GO TO 20
      GO TO 110
20    IF(GSTAY.GE.TMINVY)GO TO 21
      IF(GENDY.GE.TMINVY)GO TO 30
      GO TO 110
21    IF(GSTAY.LE.TMAXVY)GO TO 30
      IF(GENDY.LE.TMAXVY)GO TO 30
      GO TO 110
30    IF(GSTAX.NE.GENDX)GO TO 31
      DSTAX=GSTAX
      DENDX=GSTAX
      CALL PARCLT(GSTAY,GENDY,TMINVY,TMAXVY,DSTAY,DENDY)
      GO TO 120
31    IF(GSTAY.NE.GENDY)GO TO 40
      DSTAY=GSTAY
      DENDY=GSTAY
      CALL PARCLT(GSTAX,GENDX,TMINVX,TMAXVX,DSTAX,DENDX)
      GO TO 120
40    A=GENDX-GSTAX
      B=GENDY-GSTAY
      IF(GSTAX.LT.TMINVX)GO TO 41
      IF(GSTAX.LE.TMAXVX)GO TO 43
      Q=TMAXVX
      GO TO 42
43    IF(GSTAY.GT.TMAXVY)GO TO 140
      IF(GSTAY.LT.TMINVY)GO TO 44
      DSTAX=GSTAX
      DSTAY=GSTAY
      GO TO 150
41    Q=TMINVX
42    DSTAY=GSTAY+((Q-GSTAX)*B/A)
      IF(DSTAY.GT.TMAXVY)GO TO 140
      IF(DSTAY.LT.TMINVY)GO TO 44
      DSTAX=Q
      GO TO 150
44    R=TMINVY
      GO TO 45
140   R=TMAXVY
45    DSTAX=GSTAX+((R-GSTAY)*A/B)
      IF(DSTAX.GT.TMAXVX)GO TO 110
      IF(DSTAX.LT.TMINVX)GO TO 110
      DSTAY=R
150   IF(GENDX.LT.TMINVX)GO TO 50
      IF(GENDX.GT.TMAXVX)GO TO 51
      IF(GENDY.GT.TMAXVY)GO TO 160
      IF(GENDY.LT.TMINVY)GO TO 52
      DENDX=GENDX
      DENDY=GENDY
      GO TO 120
51    Q=TMAXVX
      GO TO 53
50    Q=TMINVX
53    DENDY=GSTAY+((Q-GSTAX)*B/A)
      IF(DENDY.GT.TMAXVY)GO TO 160
      IF(DENDY.LT.TMINVY)GO TO 52
      DENDX=Q
      GO TO 120
52    R=TMINVY
      GO TO 60
160   R=TMAXVY
60    DENDX=GSTAX+((R-GSTAY)*A/B)
      DENDY=R
120   OUTBF(1)=DSTAX
      OUTBF(2)=DSTAY
      OUTBF(3)=DENDX
      OUTBF(4)=DENDY
      KGNFLG=0
      GO TO 70
C * SET FLAG IF LINE OUTSIDE WINDOW
110   KGNFLG=1
70    RETURN
      END
C
C					subroutine  PARCLT
C
      SUBROUTINE PARCLT( RL1, RL2, RM1, RM2, RN1, RN2 )
      IF(RL1.LT.RM1)GO TO 10
      IF(RL1.GT.RM2)GO TO 20
      RN1=RL1
      IF(RL2-RM1)30,40,40
10    RN1=RM1
40    IF(RL2.LE.RM2)GO TO 50
      RN2=RM2
      GO TO 60
50    RN2=RL2
      GO TO 60
20    RN1=RM2
      IF(RL2.GE.RM1)GO TO 50
30    RN2=RM1
60    RETURN
      END
C
C					subroutine  LINTRN
C
      SUBROUTINE LINTRN
	include 'pcplot.inc'
      KEYCON=1
      CALL RESCAL
      RETURN
      END
C
C					subroutine  LOGTRN
C
      SUBROUTINE LOGTRN( ITYPE )
	include 'pcplot.inc'
      KEYCON=2
      TRPAR1=ITYPE
      CALL RESCAL
      RETURN
      END
C
C					subroutine  POLTRN
C
      SUBROUTINE POLTRN( ANGMIN, ANGMAX, RSUPRS )
	include 'pcplot.inc'
      KEYCON=3
      TRPAR1=ANGMIN
      TRPAR2=ANGMAX
      TRPAR5=RSUPRS
      CALL PSCAL
      RETURN
      END
C
C					subroutine  RESCAL
C
	subroutine rescal
	include 'pcplot.inc'
*	FLAG THE OLD VIRTUAL COORDINATES AS INCORRECT
      KGRAFL=0
      KGNFLG=0
      KEY=KEYCON
      IF(KEYCON .LT. 1)KEY=5
      IF(KEYCON .GT. 4)KEY=4
C * BRANCH TO PROPER SECTION AND RETURN
C * LINEAR LOG POLAR USER ERROR
      GO TO (100,200,300,400,500),KEY
C * BOTH AXES LINEAR
100   TRPAR1=0.
C * SEMI LOG OR LOG LOG
200   KEYL=TRPAR1+1.001
C * X AXIS -- LINEAR OR LOG
      GO TO (210,215,210,215),KEYL
C * LINEAR
210   TRFACX=FLOAT(KMAXSX-KMINSX)/(TMAXVX-TMINVX)
      GO TO 250
C * PREVENT INVALID TRANSFORMATION
215   IF(TMINVX .GT. 0.0 .AND. TMAXVX .GT. 0.0)GO TO 220
      KGNFLG=1
      TRPAR1=TRPAR1-1.0
      GO TO 210
C * SEMI LOG X AXIS
220   TRPAR2=ALOG(TMINVX)
      TRFACX=FLOAT(KMAXSX-KMINSX)/(ALOG(TMAXVX)-TRPAR2)
C * Y AXIS -- LINEAR OR LOG
250   GO TO (260,260,270,270),KEYL
C * LINEAR
260   TRFACY=FLOAT(KMAXSY-KMINSY)/(TMAXVY-TMINVY)
      GO TO 600
C * PREVENT INVALID TRANSFORMATION
270   IF(TMINVY .GT. 0.0 .AND. TMAXVY .GT. 0.0)GO TO 280
      KGNFLG=1
      TRPAR1=TRPAR1-2.0
      GO TO 260
C * SEMI LOG Y AXIS
280   TRPAR3=ALOG(TMINVY)
      TRFACY=FLOAT(KMAXSY-KMINSY)/(ALOG(TMAXVY)-TRPAR3)
      GO TO 600
C * POLAR SCALING
300   CALL PSCAL
      GO TO 600
C * USER FUNCTION
400   CONTINUE
C      CALL URSCAL
      GO TO 600
C * NO SCALE
500   TRFACX=1.
      TRFACY=1.
600   RETURN
      END
C
C					subroutine  PSCAL
C
      SUBROUTINE PSCAL
	include 'pcplot.inc'
      LOGICAL ANEG
      ANEG=TRPAR1 .GT. TRPAR2
C * FLAG THE OLD VIRTUAL COORDINATES AS INCORRECT
      KGRAFL=0
      PIDV2=90.00
C * SET UP UNTRANSLATED TRIAL POLAR WINDOW
      TRPAR3=0.
      TRPAR4=0.
      TRFACY=1.
      TRPAR6=0.
      R1=TMINVX
      R2=TMAXVX
      RMAX=AMAX1(ABS(R1),ABS(R2))
      TRFACX=1000./RMAX
      THMIN=AMIN1(TRPAR1,TRPAR2)
      THMAX=AMAX1(TRPAR2,TRPAR1)
C * FIND EXTREMES OF THE TRIAL POLAR WINDOW
      CALL WINCOT(R1,THMIN,IX1,IY1)
      CALL WINCOT(R1,THMAX,IX2,IY2)
      CALL WINCOT(R2,THMIN,IX3,IY3)
      CALL WINCOT(R2,THMAX,IX4,IY4)
      IXMIN=MIN0(IX1,IX2,IX3,IX4)
      IXMAX=MAX0(IX1,IX2,IX3,IX4)
      IYMIN=MIN0(IY1,IY2,IY3,IY4)
      IYMAX=MAX0(IY1,IY2,IY3,IY4)
      X=THMIN/PIDV2
      IF(THMIN.GT.0.)X=X+.999
      QUAD=FLOAT(IFIX(X))*PIDV2
      NQUAD=0
C * CHECK EXTREMES OF TRIAL WINDOW AT 90 DEGREE INTERVALS
200   IF(QUAD.GE.THMAX)GO TO 300
      NQUAD=NQUAD+1
      CALL WINCOT(R1,QUAD,IX1,IY1)
      CALL WINCOT(R2,QUAD,IX2,IY2)
      IXMIN=MIN0(IX1,IX2,IXMIN)
      IXMAX=MAX0(IX1,IX2,IXMAX)
      IYMIN=MIN0(IY1,IY2,IYMIN)
      IYMAX=MAX0(IY1,IY2,IYMAX)
      QUAD=QUAD+PIDV2
      IF(NQUAD.LT.4)GO TO 200
C * COMPUTE SCREEN AND VIRTUAL RANGES
300   TSRANX=KMAXSX-KMINSX
      TSRANY=KMAXSY-KMINSY
      XRANGE=IXMAX-IXMIN
      YRANGE=IYMAX-IYMIN
C * COMPUTE RELATIVE RADIUS SCALE FACTOR
      FACTOR=AMIN1(ABS(TSRANX)/XRANGE,ABS(TSRANY)/YRANGE)
C * COMPUTE SCREEN OFFSETS
      TRPAR3=FLOAT(KMINSX)-FACTOR*FLOAT(IXMIN)
      TRPAR4=FLOAT(KMINSY)-FACTOR*FLOAT(IYMIN)
C * COMPUTE FINAL RADIUS SCALE FACTOR
      TRFACX=TRFACX*FACTOR
C * COMPUTE ANGLE SCALE FACTOR
      TRFACY=(TRPAR2-TRPAR1)/(TMAXVY-TMINVY)
C * APPLY CORRECT SIGN TO ANGLE SCALE FACTOR
      TRFACY=SIGN(1.,TSRANX*TSRANY)*TRFACY
      AANG=0.
C * APPLY CORRECTION FOR 'REVERSED' WINDOWS
      IF(ANEG.AND.TSRANY.LT.0..OR.TSRANX.LT.0..AND..NOT.ANEG)AANG=180.
C * COMPUTE ANGLE OFFSET
      TRPAR6=TMINVY-(TRPAR1+AANG)/TRFACY
      RETURN
      END
C
C					subroutine  WINCOT
C
      SUBROUTINE WINCOT( X, Y, IX, IY )
	include 'pcplot.inc'
      DATA DE2RAD/0.01745/
C * CHECK FOR PERMITTED VALUE OF CONVERSION KEY
C * DEFAULT IS LINEAR,ERROR IS NONE
      DX=X-TMINVX
      DY=Y-TMINVY
      KEY=KEYCON
      IF(KEYCON .LT. 1)KEY=5
      IF(KEYCON .GT. 4)KEY=4
C * BRANCH TO PROPER SECTION
C * LINEAR LOG POLAR USER ERROR
      GO TO(500,300,600,700,100),KEY
C       ERROR
100   IX=X
      IY=Y
      GO TO 800
C * LOG TRANSFORM
300   KEYL=TRPAR1+.001
      IF(KEYL .EQ. 2) GO TO 400
C * SETUP X LOG TRANSFORM
      DX=ALOG(X)-TRPAR2
400   IF(KEYL .EQ. 1) GO TO 500
C * SETUP Y LOG TRANSFORM
      DY=ALOG(Y)-TRPAR3
C * CONVERT LINEAR
500   IX=IFIX(DX*TRFACX+.5)+KMINSX
      IY=IFIX(DY*TRFACY+.5)+KMINSY
C * GO TO EXIT
      GO TO 800
C * POLAR TRANSFORMATION
600   A=(Y-TRPAR6)*TRFACY
      R=(X-TRPAR5)*TRFACX
      IX=R*COS(A*DE2RAD)+TRPAR3
      IY=R*SIN(A*DE2RAD)+TRPAR4
C * GO TO EXIT
      GO TO 800
C * USER TRANSFORMATION IN USE
700   CONTINUE
C      CALL USECOT(X,Y,IX,IY)
C * EXIT POINT
800   RETURN
      END
C
C					SUBROUTINE  LVLCHT
C
      SUBROUTINE LVLCHT
	include 'pcplot.inc'
	IF( KGRAFL .NE. 0 ) GO TO 10
	CALL REVCOT( KBEAMX, KBEAMY, TREALX, TREALY )
	TIMAGX = TREALX
	TIMAGY = TREALY
	KGRAFL = 1
   10	RETURN
	END
C
C					SUBROUTINE  REVCOT
C
      SUBROUTINE REVCOT( IX, IY, X, Y )
      LOGICAL DEC
	include 'pcplot.inc'
      E=2.7182818284
      DX=FLOAT(IX-KMINSX)/TRFACX
      DY=FLOAT(IY-KMINSY)/TRFACY
      KEY=KEYCON
      IF(KEYCON .LT. 1)KEY=5
      IF(KEYCON .GT. 4)KEY=4
C *       LINEAR LOG POLAR USER ERROR
      GO TO(300, 400, 500, 600, 100  ),KEY
C * ERROR
100   X=IX
      Y=IY
      GO TO 700
C * LINEAR
300   X=DX+TMINVX
      Y=DY+TMINVY
      GO TO 700
C * LOG SCALES
400   KEYL=TRPAR1
      X=DX+TMINVX
      Y=DY+TMINVY
      IF(KEYL .EQ. 1 .OR. KEYL .EQ. 3)X=E**(DX+TRPAR2)
      IF(KEYL .EQ. 2 .OR. KEYL .EQ. 3)Y=E**(DY+TRPAR3)
      GO TO 700
C * POLAR
500   DX=FLOAT(IX)-TRPAR3
      DY=FLOAT(IY)-TRPAR4
      Y=ATAN2(DY,DX)*57.2957795131
      X=SQRT(DY*DY+DX*DX)/TRFACX+TRPAR5
C * ADJUST ANGLE MOD 2 PI TO VALUE WITHIN WINDOW
      DEC=.FALSE.
510   IF(Y .GT. TRPAR1) GO TO 530
C * INCREMENT ANGLE
      Y=Y+360.0
      GO TO 510
530   IF(Y .LE. TRPAR2) GO TO 550
C * DECREMENT ANGLE
      Y=Y-360.0
      DEC=.TRUE.
      GO TO 530
550   IF(DEC .AND. Y .LT. TRPAR1)Y=Y+360.0
      IF(TMINVX .GE. 0.)GO TO 560
      TR1A=AMOD(TRPAR1+180.,360.)
      TR2A=AMOD(TRPAR2+180.,360.)
      IF(Y.GT.AMAX1(TR1A,TR2A).OR.Y.LT.AMIN1(TR1A,TR2A))GO TO 560
      Y=AMOD(Y+180.,360.)
      X=-X
560   Y=Y/TRFACY+TRPAR6
      GO TO 700
C * USER CONVERSION
600   CONTINUE
C      CALL UREVCT(IX,IY,X,Y)
*	EXIT POINT		
c	Screen location determined.
  700	CONTINUE
	CALL PCLIPT( X, Y )	
c	Check to see if point is in plotting region
      RETURN
      END
*
*					SUBROUTINE  PCLIPT
*
*
*	This subroutine checks the data to ensure that the point is withing
*	the working window.  If the point should be visible then the 
*	variable KGNFLG is set to 0.  If the point falls outside the 
*	visible window then KGNFLG = 1.
*
      SUBROUTINE PCLIPT( X, Y )
	include 'pcplot.inc'
      KGNFLG=0
      IF(X.LT.TMINVX)GO TO 10
      IF(X.GT.TMAXVX)GO TO 10
      IF(Y.LT.TMINVY)GO TO 10
      IF(Y.LE.TMAXVY)GO TO 20
10    KGNFLG=1
20    RETURN
      END
C
C					subroutine  PNTREL
C
      SUBROUTINE PNTREL( IX, IY )
	include 'pcplot.inc'
      JX=KBEAMX+IX
      JY=KBEAMY+IY
      CALL PNTABS(JX,JY)
      RETURN
      END
C
C					subroutine  PNTABS
C
      SUBROUTINE PNTABS( IX, IY )
	include 'pcplot.inc'
      IF(KKMODE .NE. 2)CALL PNTMOD
      CALL TKPNT(IX,IY)
      KGRAFL=0
      RETURN
      END
C
C					subroutine  DRWREL
C
      SUBROUTINE DRWREL( IX, IY )
	include 'pcplot.inc'
      JX=KBEAMX+IX
      JY=KBEAMY+IY
      CALL DRWABS(JX,JY)
      RETURN
      END
C
C					subroutine  DRWABS
C
      SUBROUTINE DRWABS( IX, IY )
	include 'pcplot.inc'
C * NON-4014/15 PRUNING BOUNDARY
C * SET TERMINAL TO DRAW SOLID LINES
C * THIS SECTION IS FOR 4014 ENHANCED **********************************
      IF(KLINE .EQ. 0)GO TO 5
      KLINE=0
      CALL CWSEND
5     CONTINUE
C **********************************************************************
      IF(KKMODE.NE.1)CALL VECMOD
      IF(KMOVEF.EQ.1)CALL XYCNVT(KBEAMX,KBEAMY)
      CALL XYCNVT(IX,IY)
      KGRAFL=0
      RETURN
      END
C
C					subroutine  SETMRG
C
      SUBROUTINE SETMRG( MLEFT, MRIGHT )
	include 'pcplot.inc'
      KLMRGN=MLEFT
      KRMRGN=MRIGHT
      RETURN
      END
C
C					subroutine  MOVREL
C
      SUBROUTINE MOVREL( IX, IY )
	include 'pcplot.inc'
      JX=KBEAMX+IX
      JY=KBEAMY+IY
      CALL MOVABS(JX,JY)
      RETURN
      END
C
C					subroutine  SETTAB
C
      SUBROUTINE SETTAB( ITAB, ITBTBL )
      DIMENSION ITBTBL(*)
	include 'pcplot.inc'
      KGNFLG=0
      IF(ITAB.LE.0)GO TO 10
      I=1
20    IF(ITBTBL(I).EQ.ITAB)GO TO 10
      IF(ITAB.LT.ITBTBL(I))GO TO 60
      IF(ITBTBL(I).EQ.0)GO TO 60
      I=I+1
      IF(I.LE.KTBLSZ)GO TO 20
30    KGNFLG=1
10    RETURN
60    ITEMP=ITBTBL(I)
      ITBTBL(I)=ITAB
70    IF(ITEMP.EQ.0)GO TO 10
      I=I+1
      IF(I.GT.KTBLSZ)GO TO 30
      ITEMPA=ITBTBL(I)
      ITBTBL(I)=ITEMP
      ITEMP=ITEMPA
      GO TO 70
      END
C
C					subroutine  RSTTAB
C
      SUBROUTINE RSTTAB( ITAB, ITBTBL )
      DIMENSION ITBTBL(*)
	include 'pcplot.inc'
      IF(ITAB)10,20,30
30    DO 40 I=1,KTBLSZ
      IF(ITAB.EQ.ITBTBL(I))GO TO 50
40    CONTINUE
      GO TO 10
50    J=KTBLSZ-1
      DO 60 K=I,J
60    ITBTBL(K)=ITBTBL(K+1)
      ITBTBL(KTBLSZ)=0
      GO TO 10
20    DO 21 II=1,KTBLSZ
21    ITBTBL(II)=0
10    RETURN
      END
C
C					subroutine  TABHOR
C
      SUBROUTINE TABHOR( ITBTBL )
      DIMENSION ITBTBL(*)
	include 'pcplot.inc'
      KFLG=0
      DO 10 K=1,KTBLSZ
      IF(ITBTBL(K).NE.0)KFLG=1
      IF(ITBTBL(K).GT.KBEAMX)GO TO 20
10    CONTINUE
      IF(KFLG.EQ.0)GO TO 30
15    CALL NEWLIN
      GO TO 30
20    IF (ITBTBL(K).GE.KRMRGN) GO TO 15
      CALL MOVABS(ITBTBL(K),KBEAMY)
      CALL ALFMOD
30    RETURN
      END
C
C					subroutine  TABVER
C
      SUBROUTINE TABVER( ITBTBL )
      DIMENSION ITBTBL (*)
	include 'pcplot.inc'
      DO 10 K=1,KTBLSZ
      I=KTBLSZ-K+1
      IF(ITBTBL(I) .LE. 0)GO TO 10
      IF(ITBTBL(I) .LT. KBEAMY)GO TO 30
10    CONTINUE
      GO TO 20
30    CALL MOVABS(KBEAMX,ITBTBL(I))
      CALL ALFMOD
20    RETURN
      END
C
C					subroutine  DSHMOD
C
      SUBROUTINE DSHMOD( L )
	include 'pcplot.inc'
      IF(KKMODE .EQ. 4) GO TO 10
      KKMODE=4
C * OUTPUT (US) TO CANCEL PREVIOUS MODE
      CALL TOUTPT(31)
C * CANCEL OPTIMIZATION AND INSERT MOVE TO CURRENT LOCATION
      CALL TOUTPT(29)
      KMOVEF=1
      DO 5 I=1,5
5     KPCHAR(I)=-1
      CALL XYCNVT(KBEAMX,KBEAMY)
10    KDASHT=L
      RETURN
      END
C
C					subroutine  TKDASH
C
      SUBROUTINE TKDASH( IX, IY )
	include 'pcplot.inc'
      DIMENSION DTABL(10), U(9), WORK(10),ISIMHD(4)
      DATA ISIMHD(1),ISIMHD(2),ISIMHD(3),ISIMHD(4)/12,31212,32,52/
      DATA IDTYPE/-1/ work/10*0.0/
      DATA U(1),U(2),U(3),U(4),U(5)/5.,-5.,10.,-10.,25./
      DATA U(6),U(7),U(8),U(9)/-25.,50.,-50.,0./
      DATA LASTX,LASTY,NO,SEGLEN/-1,-1,0,0/
      DATA DTABL(2)/0./
c     Below to keep values of i and no between calls - SLT,DC 3-2000
      data i,no/0,0/
      IF(KDASHT .LT. 0)GO TO 320
      IF(KDASHT .GT. 4)GO TO 101
C * SET TERMINAL FOR HARDWARE DASHED LINES
C * THIS SECTION IS FOR 4014 ENHANCED **********************************
      IF(KTERM .GE. 3)GO TO 103
      IF(KDASHT .EQ. 0)GO TO 330
C **********************************************************************
C * HARDWARE DASH SIMULATION FOR TYPE 1 + 2 TERMINALS
      KDASHT=ISIMHD(KDASHT)
101   CONTINUE
C * THIS SECTION IS ALSO FOR 4014 ENHANCED *****************************
      IF(KLINE .EQ. 0)GO TO 104
      KLINE=0
      CALL CWSEND
      GO TO 104
C * SET AND TRANSMIT HARDWARE DASH CODE
103   IF(KLINE .EQ. KDASHT)GO TO 330
      KLINE=KDASHT
      CALL CWSEND
      GO TO 330
104   CONTINUE
C **********************************************************************
      IF(KDASHT .EQ. 0)GO TO 330
      IF(KDASHT .EQ. IDTYPE)GO TO 170
C * BUILD NEW DASH TABLE
      ICHAR=KDASHT
      DO 140 NO=1,10
120   IF(ICHAR)130,150,130
130   I=ICHAR-((ICHAR/10)*10)
      ICHAR=ICHAR/10
      IF(I)140,120,140
140   WORK(NO)=U(I)
      NO=11
150   NO=NO-1
C * INVERT TABLE AND STORE IN DTABLE
      DO 160 I=1,NO
      ISUB=NO+1-I
160   DTABL(I)=WORK(ISUB)
C * MODIFIY TABLE TO COMPENSATE FOR FLARE
      D1=DTABL(1)
      NUM=NO-1
      DO 165 K=1,NUM
      DCUR=DTABL(K)
      IF(DCUR*DTABL(K+1).GT.0. .OR. DCUR*D1 .LT.0.)GO TO 165
      DTABL(K)=DTABL(K)-1.
      DTABL(K+1)=DTABL(K+1)-1.
165   CONTINUE
      IDTYPE=KDASHT
      I=0
      SEGLEN=0
C * BRANCH FOR ALTERNATING AND SOLID
170   IF(NO-1)320,330,180
180   IF(LASTX-KBEAMX)200,190,200
190   IF(LASTY-KBEAMY)200,210,200
C * SET START OF SEQUENCE IF NOT INTERRUPTED BY A MOVE
200   SEGLEN=0
      I=0
C * COMPUTE NEXT SEGMENT LENGTH
210   X=FLOAT(KBEAMX)
      Y=FLOAT(KBEAMY)
      DX=FLOAT(IX-KBEAMX)
      DY=FLOAT(IY-KBEAMY)
      DIAG=SQRT(DX*DX+DY*DY)
      DIST=DIAG
      IF (SEGLEN-1.5)220,220,230
220   I=MOD(I,NO)+1
      SEGLEN=ABS(DTABL(I))
230   IF(SEGLEN-DIST)240,270,270
240   F=SEGLEN/DIAG
      X=X+DX*F
      Y=Y+DY*F
      IF (DTABL(I))250,250,260
C * OUTPUT A GS FOR A DARK VECTOR
250   CALL TOUTPT(29)
      KMOVEF=1
260   CALL XYCNVT(IFIX(X),IFIX(Y))
C * CALCULATE REMAINING DISTANCE TO POINT
      DIST=DIST-SEGLEN
      SEGLEN=0
      GO TO 220
270   IF(DTABL(I))280,280,290
280   CALL TOUTPT(29)
      KMOVEF=1
C * THAT WAS A GS FOR AN INVISIBLE LINE
290   CALL XYCNVT(IX,IY)
      LASTX=IX
      LASTY=IY
C * CALCULATE SEGMENT FRAGMENT UNUSED
      SEGLEN=SEGLEN-DIST
      GO TO 340
320   CALL TOUTPT(29)
      KMOVEF=1
330   CALL XYCNVT(IX,IY)
      NO=1-NO
      IDTYPE=KDASHT
340   RETURN
      END
C
C					subroutine  HDCOPY
C
      SUBROUTINE HDCOPY
      DIMENSION ICODE(2)
      DATA ICODE(1),ICODE(2)/27,23/
C *  OUTPUT (ESC) (ETB) TO START HARD COPY
      CALL TOUTST(2,ICODE)
      CALL IOWIAT(180)
      RETURN
      END
C
C----------FUNCTION----KIN
C
      FUNCTION KIN(RI)
	include 'pcplot.inc'
      KIN=RI*546.0/FLOAT(KFACTR)
C * USE APPROPRIATE FACTOR FOR LARGE SCREEN TERMINALS
      IF(KTERM .GT. 1)KIN=RI*285.7/FLOAT(KFACTR)
      RETURN
      END
C
C----------FUNCTION----KCM
C
      FUNCTION KCM(RC)
	include 'pcplot.inc'
      KCM=RC*215.2/FLOAT(KFACTR)
C * USE APPROPRIATE FACTOR FOR LARGE SCREEN TERMINALS
      IF(KTERM .GT. 1)KCM=RC*112.48/FLOAT(KFACTR)
      RETURN
      END
C
C					subroutine  DCURSR
C
      SUBROUTINE DCURSR( ICHAR, IX, IY )
      CALL SCURSR(ICHAR,IX,IY)
      RETURN
      END
C
C					subroutine  SCURSR
C
      SUBROUTINE SCURSR( ICHAR, IX, IY )
	include 'pcplot.inc'
      DIMENSION ICODE(2),IN(5)
      DATA ICODE(1),ICODE(2)/27,26/
C * SET THE GRAPHIC INPUT FLAG
      KGNMOD=1
C * OUTPUT (ESC) (SUB) TO TURN ON CURSOR
      IF(KTERM .GT. 0) CALL TOUTST(2,ICODE)
C * CURSER SHOULD ALWAYS INPUT A NEW BUFFER
      KINLFT=0
      CALL TINSTR(5,IN)
C * REMOVE THE GRAPHIC INPUT FLAG
      KGNMOD=0
C * RESTORE THE TERMINAL STATUS
      CALL RECOVR
      ICHAR=IN(1)
C * DECODE SCREEN CO-ORDINATES
      IX=MOD(IN(2),32)*32+MOD(IN(3),32)
      IY=MOD(IN(4),32)*32+MOD(IN(5),32)
C * APPLY SCREEN SCALE FACTOR
      IX=IX*4/KFACTR
      IY=IY*4/KFACTR
      RETURN
      END
C
C					subroutine  A1IN
C
      SUBROUTINE A1IN( NCHAR, IA1 )
      DIMENSION IADE( 72 ),IA1(*)
      DATA MAXLEN / 72 /
      LEN=NCHAR
      IF(LEN .GT. MAXLEN)LEN=MAXLEN
      CALL TINSTR(LEN,IADE)
      CALL KAS2A1(LEN,IADE,IA1)
      RETURN
      END
C
C					subroutine  AINST
C
      SUBROUTINE AINST( NCHAR, IAM )
      DIMENSION IADE(72), IAM(*)
      DATA MAXLEN / 72 /
      LEN = NCHAR
      IF( LEN .GT. MAXLEN ) LEN = MAXLEN
      CALL TINSTR( LEN, IADE )
      CALL KAS2AM( LEN, IADE, IAM )
      RETURN
      END
C
C					subroutine  TINPUT
C
      SUBROUTINE TINPUT( IN )
      DIMENSION INT(1)
      CALL TINSTR( 1, INT )
      IN=INT(1)
      RETURN
      END
C
C					subroutine  TINSTR
C
      SUBROUTINE TINSTR( NCHAR, IADE )
	include 'pcplot.inc'
      DIMENSION INBUFF(72),IADE(*)
      DATA ISENT,IGOT,IPAD/0,0,32/
      IF(KINLFT .GT. 0)GO TO 10
C * REQUEST A NEW INPUT BUFFER
C * PUT OUT THE OUTPUT BUFFER
      CALL TSEND
      CALL ADEIN(IGOT,INBUFF)
      IF(KTERM.GE.3) CALL CWSEND
      ISENT=0
      KINLFT=IGOT
10    LEN=NCHAR
      IF(LEN .LE. 0)GO TO 50
      DO 20 I=1,LEN
      ISENT=ISENT+1
      ITMP=I
      IF(ISENT .GT. IGOT)GO TO 30
20    IADE(I)=INBUFF(ISENT)
      KINLFT=IGOT-ISENT
      GO TO 50
C * PAD WITH BLANKS WHEN NEEDED
30    DO 40 I=ITMP,LEN
40    IADE(I)=IPAD
      KINLFT=0
50    RETURN
      END
C
C					subroutine  SVSTAT
C
      SUBROUTINE SVSTAT( RARRAY )
	include 'pcplot.inc'
      DIMENSION RARRAY(60),IB(41),RB(19)
      EQUIVALENCE (IB(1),KMOFLG(1)),(RB(1),TMINVX)
C * COPY TERMINAL STATUS AREA INTO GIVEN SAVE ARRAY
      DO 100 I=1,19
100   RARRAY(I)=RB(I)
      DO 101 I=1,41
101   RARRAY(I+19)=IB(I)
      RETURN
      END
C
C					subroutine  RESTAT
C
      SUBROUTINE RESTAT( RARRAY )
	include 'pcplot.inc'
      DIMENSION RARRAY(60),IB(41),RB(19)
      EQUIVALENCE (IB(1),KMOFLG(1)),(RB(1),TMINVX)
C * COPY GIVEN STATUS INTO TCS COMMON
      DO 100 I=1,19
100   RB(I)=RARRAY(I)
      DO 101 I=1,38
101   IB(I)=RARRAY(I+19)
C * RESTORE CHARACTER SIZE
      IF(KTERM .GT. 1)CALL CHRSIZ(KSIZEF)
C * RESTORE ZAXIS AND DASH LINE
      IF(KTERM .GT. 2)CALL CWSEND
C * CALL TO RECOVER POSITION AND MODE
      CALL RECOVR
      RETURN
      END
C
C					subroutine  SEELOC
C
      SUBROUTINE SEELOC( IX, IY )
	include 'pcplot.inc'
      IX=KBEAMX
      IY=KBEAMY
      RETURN
      END
C
C					subroutine  SEEBUF
C
      SUBROUTINE SEEBUF( KFORM )
	include 'pcplot.inc'
      KFORM=KUNIT
      RETURN
      END
C
C					subroutine  SETBUF
C
      SUBROUTINE SETBUF( KFORM )
	include 'pcplot.inc'
	KUNIT = KFORM
*
*	Check for out of bounds format types.
*
	IF( KUNIT .LT. 1 ) KUNIT = 1
	IF( KUNIT .GT. 4 ) KUNIT = 4
*
*	Set the maximum output character count depending of buffer type
*
	IF( KUNIT .LT. 3 ) THEN
	  KACHAR = KOBLEN - 11 - KPAD2
	  KTRAIL = 1
	ELSE IF( KUNIT .GE. 3 ) THEN
	  KACHAR = KOBLEN
	  KTRAIL = 0
	END IF
 	RETURN
 	END
C
C----------FUNCTION----LEFTIO
C
      FUNCTION LEFTIO(IOBUF)
	include 'pcplot.inc'
      ITEMP=KINLFT
      IF( IOBUF .EQ. 0 ) ITEMP = KOTLFT
      LEFTIO=ITEMP
      RETURN
      END
C
C					subroutine  RESET
C
      SUBROUTINE RESET
	include 'pcplot.inc'
      KEYCON=1
      TRFACX=1.
      TRFACY=1.
      KBEAMX=0
      KHOMEY=3068/KFACTR
      KBEAMY=KHOMEY
      KMINSX=0
      KMAXSX=4095/KFACTR
      KMINSY=0
      KMAXSY=3120/KFACTR
      KHORSZ=56
      KLINE=0
      KZAXIS=0
      KLMRGN=0
      KRMRGN=4088/KFACTR
      KSIZEF=1
      KTBLSZ=10
      KVERSZ=88
      TMINVX=0.
      TMAXVX=KMAXSX
      TMINVY=0.
      TMAXVY=KMAXSY
      TRCOSF=1.
      TRSINF=0.
      TRSCAL=1.
C * MOVE TO THE HOME POSITION
      CALL MOVABS( KLMRGN, KHOMEY )
C * SET 4014 ENHANCED FOR SOLID LINES
      IF(KTERM .GE. 3) CALL CWSEND
C * PLACE 4014 IN LARGE CHARACTER SIZE
        IF(KTERM .GE. 2) CALL CHRSIZ( 1 )
C * PLACE THE TERMINAL IN A/N MODE
      CALL ALFMOD
      RETURN
      END
C
C					subroutine  TKPNT
C
      SUBROUTINE TKPNT( IX, IY )
	include 'pcplot.inc'
*	THIS SECTION IS FOR 4014 ENHANCED ******************************
	IF( KTERM .GE. 3 ) GO TO 10
*	****************************************************************
*	PUT OUT A GS FOR SIMULATED POINT PLOT MODE
	CALL TOUTPT(29)
	KMOVEF = 1
	CALL XYCNVT( IX, IY )		
c	Move to the point
  10	CALL XYCNVT( IX, IY )		
c	Draw the point
	RETURN
	END
C
C					FUNCTION    GENFLG
C
      LOGICAL FUNCTION GENFLG(ITEM)
	include 'pcplot.inc'
      GENFLG=KGNFLG .EQ. ITEM
      RETURN
      END
C
C					subroutine  ANCHO
C
      SUBROUTINE ANCHO( ICHAR )
	include 'pcplot.inc'
      IF(KKMODE.EQ.0)GO TO 10
      CALL ALFMOD
10    IF(KBEAMX.LT.KRMRGN-KHORSZ/KFACTR) GO TO 20
      CALL NEWLIN
20    CALL TOUTPT(ICHAR)
C * ROUND NON-INTEGER CHARACTER WIDTH IN 1023 CO-ORDINATES
      KBEAMX=KBEAMX+(KHORSZ+KFACTR/2)/KFACTR
      RETURN
      END
C
C					subroutine  ANSTR
C
      SUBROUTINE ANSTR( NCHAR, IADE )
	include 'pcplot.inc'
      DIMENSION IADE(*)
      MAXLEN = KACHAR
      IPT=1
C * PLACE THE TERMINAL IN A/N MODE, IF NEEDED
      IF(KKMODE .NE. 0)CALL ALFMOD
C * GET A NEWLINE WHEN THE BEAM POSITION IS OUTSIDE MARGINS
      IF(KBEAMX .LT. KLMRGN)GO TO 10
5     IF(KBEAMX .LE. KRMRGN-KHORSZ/KFACTR)GO TO 20
      IF(KBEAMX .LT. 4092/KFACTR)GO TO 10
      KBEAMX=KLMRGN
      KBEAMY=KBEAMY-(KVERSZ+KFACTR/2)/KFACTR
      IF(KBEAMY .LT. 0)KBEAMY=KHOMEY
      GO TO 20
10    CALL NEWLIN
C * CALCULATE NUMBER OF CHARACTERS POSSIBLE TO PUT ON LINE
20    ISEND=((KRMRGN-KBEAMX)*KFACTR)/KHORSZ
C * PUT OUT AT LEAST ONE CHARACTER
      IF(ISEND .LT. 1)ISEND=1
C * DON'T SEND ENOUGH CHARACTERS TO CAUSE BUFFER TRUNCATION
      IF(ISEND .GT. MAXLEN)ISEND=MAXLEN
      IEND=IPT+ISEND-1
C * SEND ONLY NUMBER OF CHARACTERS RECEIVED
      IF(IEND .GT. NCHAR)ISEND=NCHAR-IPT+1
      CALL TOUTST(ISEND,IADE(IPT))
C * UPDATE THE BEAM
      KBEAMX=KBEAMX+(ISEND*KHORSZ+KFACTR/2)/KFACTR
      IF(KBEAMX .GT. 4092/KFACTR)KBEAMX=4092/KFACTR
      IPT=IPT+ISEND
C * REPEAT ON NEWLINE UNTIL ALL CHARACTERS SENT
      IF(IEND .LT. NCHAR)GO TO 5
      RETURN
      END
C
C					subroutine  NEWLIN
C
      SUBROUTINE NEWLIN
      CALL CARTN
      CALL LINEF
      RETURN
      END
C
C					subroutine  CARTN
C
      SUBROUTINE CARTN
	include 'pcplot.inc'
      IF(KLMRGN.EQ.0)GO TO 10
C * IF (CR) CAN NOT BE SENT REMOVE ALL EXECUTEABLE CODE EXCEPT NEXT 2
C * LINES AND RETURN
      CALL MOVABS(KLMRGN,KBEAMY)
      CALL ALFMOD
      GO TO 30
10    IF(KKMODE.NE.0)CALL ALFMOD
C * OUTPUT (CR)
      CALL TOUTPT(13)
      KBEAMX=0
C * RESTORE ZAXIS STATE ON 4014
      IF(KTERM .GE. 2)CALL CWSEND
30    RETURN
      END
C
C					subroutine  LINEF
C
      SUBROUTINE LINEF
	include 'pcplot.inc'
C * IF (LF) CAN NOT BE SENT REMOVE NEXT 2 EXECUTEABLE LINES AND
C * CHANGE 'GO TO' FROM 200 TO 100
      IF(KKMODE .NE. 0)CALL ALFMOD
C * OUTPUT (LF)
      CALL TOUTPT(10)
      KBEAMY=KBEAMY-(KVERSZ+KFACTR/2)/KFACTR
      IF(KBEAMY .GE. 0)GO TO 200
      KBEAMY=KHOMEY
100   CALL MOVABS(KBEAMX,KBEAMY)
      CALL ALFMOD
C * RESTORE ZAXIS MODE IF APPROPRIATE
200   IF(KTERM .GE. 2)CALL CWSEND
      RETURN
      END
C
C					subroutine  BAKSP
C
      SUBROUTINE BAKSP
	include 'pcplot.inc'
      IF(KKMODE.NE.0)CALL ALFMOD
C * OUTPUT (BS)
      IF (KTERM .GT. 0)CALL TOUTPT(8)
      KBEAMX=KBEAMX-(KHORSZ+KFACTR/2)/KFACTR
      IF(KBEAMX.GE.0)GO TO 10
      KBEAMX=KBEAMX+4095/KFACTR
10    IF(KTERM .GT. 0)GO TO 20
      CALL MOVABS(KBEAMX,KBEAMY)
      CALL ALFMOD
20    RETURN
      END
C
C					subroutine  HOME
C
      SUBROUTINE HOME
	include 'pcplot.inc'
      CALL MOVABS(KLMRGN,KHOMEY)
      CALL ALFMOD
      RETURN
      END
C
C					subroutine  ERASE
C
      SUBROUTINE ERASE
      DIMENSION ICODE(2)
      DATA ICODE(1),ICODE(2)/27,12/
      CALL TOUTST(2,ICODE)
      CALL IOWIAT(10)
      CALL RECOVR
      RETURN
      END
C
C					subroutine  RECOVR
C
      SUBROUTINE RECOVR
	include 'pcplot.inc'
C * SAVE THE GRAPHIC LEVEL FLAG
      IFLAG=KGRAFL
C * REMOVE MOVE FLAG
      KMOVEF=0
C * SAVE THE MODE
      MODE=KKMODE+1
C * SAVE THE Y-COORDINATE
      IY=KBEAMY
C * CLEAR ALL OTHER MODES
      CALL ALFMOD
C * MOVE TO SCREEN LOCATION
      CALL MOVABS(KBEAMX,IY)
C * SET THE HARDWARE DASH AND Z-AXIS WHEN NEEDED
      IF(KTERM .GE. 2)CALL CWSEND
C * PLACE IN THE PROPER MODE
      IF(MODE .LT. 1)MODE=1
      IF(MODE .GT.5)MODE=5
      GO TO (100,200,120,100,200),MODE
100   CALL ALFMOD
      GO TO 200
120   CALL PNTMOD
C * RESTORE THE GRAPHIC LEVEL FLAG
200   KGRAFL=IFLAG
      RETURN
      END
C
C					subroutine  NEWPAG
C
      SUBROUTINE NEWPAG
	include 'pcplot.inc'
      DIMENSION ICODE(2)
      DATA ICODE(1),ICODE(2)/27,12/
      IF(KKMODE .NE. 0)CALL ALFMOD
C * OUTPUT (ESC) (FF) FOR NEW PAGE
      CALL TOUTST(2,ICODE)
      CALL IOWIAT(10)
      IF(KLMRGN.EQ.0)GO TO 10
      CALL MOVABS(KLMRGN,KHOMEY)
      CALL ALFMOD
      GO TO 20
10    KBEAMX=0
      KBEAMY=KHOMEY
20    RETURN
      END
C
C					subroutine  ALFMOD
C
      SUBROUTINE ALFMOD
	include 'pcplot.inc'
C	SET ALPHA MODE OUTPUT (US)
      CALL TOUTPT(31)
      KGRAFL=0
      KKMODE=0
      IF(KBEAMY.GT.KHOMEY) KBEAMY=KHOMEY
      RETURN
      END
C
C					subroutine  MOVABS
C
      SUBROUTINE MOVABS( IX, IY )
	include 'pcplot.inc'
      CALL VECMOD
      CALL XYCNVT(IX,IY)
      KGRAFL=0
      RETURN
      END
C
C					subroutine  IOWIAT
C
      SUBROUTINE IOWIAT( ITIME )
C	THIS ROUTINE IS USED TO GENERATE DELAYS FOR REMOTE TERMINALS
	include 'pcplot.inc'
      IF(KBAUDR.LE.0)GO TO 20
      KOUNT=ITIME*(KBAUDR/10)
      DO 10 J=1,KOUNT
C	OUTPUT (SYN) TO INSURE AGAINST LOSS OF OUTPUT WHILE
C	TERMINAL IS BUSY. (SYN) DOES NOT AFFECT THE TERMINAL.
10    CALL TOUTPT(22)
20    RETURN
      END
C
C					subroutine  VECMOD
C
      SUBROUTINE VECMOD
	include 'pcplot.inc'
      IF(KKMODE.EQ.1)GO TO 10
C * OUTPUT (US) TO ENTER A/N MODE AND RESET FOR VECTOR MODE
      CALL TOUTPT(31)
      DO 112 II=1,5
112   KPCHAR(II)=-1
      KKMODE=1
C * OUTPUT (GS) TO ENTER VECTOR MODE
10    CALL TOUTPT(29)
      KMOVEF=1
      RETURN
      END
C
C					subroutine  CSIZE
C
      SUBROUTINE CSIZE( IHORZ, IVERT )
	include 'pcplot.inc'
      IHORZ=(KHORSZ+KFACTR/2)/KFACTR
      IVERT=(KVERSZ+KFACTR/2)/KFACTR
      RETURN
      END
C
C					subroutine  PNTMOD
C
      SUBROUTINE PNTMOD
	include 'pcplot.inc'
*	CANCEL PREVIOUS MODES - OUTPUT (US)
	CALL TOUTPT(31)
	DO 111 II=1,5
  111	KPCHAR(II) = -1
	KKMODE = 2
*	FOR HARDWARE POINT PLOT OUTPUT AN (FS)
	IF( KTERM .GE. 3 ) CALL TOUTPT(28)
	RETURN
	END
C
C					subroutine  IPMOD
C
      SUBROUTINE IPMOD
	include 'pcplot.inc'
      DIMENSION ICODE(2)
      DATA ICODE(1),ICODE(2)/31,30/
C * OUTPUT (US) TO CANCEL PREVIOUS MODE AND (RS) TO SET INCPLT MODE
      CALL TOUTST(2,ICODE)
      KKMODE=3
      KGRAFL=0
      RETURN
      END
C
C					SUBROUTINE  XYCNVT
C
      SUBROUTINE XYCNVT( IX, IY )
	include 'pcplot.inc'
      DIMENSION IPLT(5),IOPT(8)
	DATA IDREW, ISYN / 0, 22 /
*	RECEIVE THE PLOT CHARACTERS
	CALL PLTCHR( IX, IY, IPLT )	
c	Receive the plot characters
*
*	The next section section optimizes the output plot characters to 
*	get more speed from the program.
*
	LEN = 0				
c	Initialize length of string to 0
	IF( KPCHAR(1) .EQ. IPLT(1) )
     .			 GO TO 10	
c	Is high Y needed?
	LEN=1				
c	If high Y needed, include it.
	KPCHAR(1) = IPLT(1)
	IOPT(1)   = IPLT(1)		
c	Put character in output string.
*
* CHECK IF LSBYX IS NEEDED
*
   10	IF( KTERM .LE. 2 ) GO TO 20
	IF( KPCHAR(2) .EQ. IPLT(2) ) GO TO 20
	LEN = LEN + 1			
c	Incluce LSBYX if needed.
	KPCHAR(2) = IPLT(2)
	IOPT(LEN) = IPLT(2)		
c	Store LSBYX in output string.
	GO TO 30
*
* CHECK IF LOW Y IS NEEDED
*
   20	IF( KPCHAR(3) .NE. IPLT(3) ) GO TO 30
	IF( KPCHAR(4) .EQ. IPLT(4) ) GO TO 40
   30	LEN = LEN + 1			
c	INCLUDE LOW Y IF NEEDED
	KPCHAR(3) = IPLT(3)
	IOPT(LEN) = IPLT(3)
*
* CHECK IF HIGH X IS NEEDED
*
	IF( KPCHAR(4) .EQ. IPLT(4) ) GO TO 50
	LEN = LEN + 1			
c	INCLUDE HIGH X IF NEEDED
	KPCHAR(4) = IPLT(4)
	IOPT(LEN) = IPLT(4)
*
* CHECK IF LOW X IS NEEDED
*
   40	IF( KPCHAR(5) .NE. IPLT(5) ) GO TO 50
*	CHECK IF ALL THE CHARACTERS ARE THE SAME
	IF( LEN .NE. 0 ) GO TO 50
*	CHECK IF (GS) FOR DARK VECTOR ALREADY SENT
	IF( KMOVEF .EQ. 1 ) GO TO 50
*	CHECK IF VECTOR IS ALREADY DRAWN TO SPOT
	IF( IDREW .EQ. 1 ) GO TO 80
*	INCLUDE THE LOW X
   50	LEN = LEN + 1
	KPCHAR(5) = IPLT(5)
	IOPT(LEN) = IPLT(5)
*	CHECK FOR POSSIBLE SPEED
C * SEND THE ARRAY TO THE OUTPUT BUFFER
   70	CONTINUE
	CALL TOUTST( LEN, IOPT )
*
*	Set the COMMON and history variables.
*
	IDREW = 1			
c	Set the drew here flag.
	IF( KMOVEF .EQ. 1 ) IDREW = 0	
c	Remove the drew flag if did not draw
	KMOVEF = 0			
c	Remove the move flag.
   80	KBEAMX = IX
	KBEAMY = IY
	RETURN
	END
C
C----------FUNCTION----LINWDT
C
      FUNCTION LINWDT(NUMCHR)
	include 'pcplot.inc'
      LINWDT=(KHORSZ * NUMCHR + KFACTR/2)/KFACTR
      RETURN
      END
C
C----------FUNCTION----LINHGT
C
      FUNCTION LINHGT(NUMLIN)
	include 'pcplot.inc'
      LINHGT=(KVERSZ * NUMLIN + KFACTR/2)/KFACTR
      RETURN
      END
C
C					subroutine  CHRSIZ
C
      SUBROUTINE CHRSIZ( K )
	include 'pcplot.inc'
      DIMENSION ICODE(2),ICHRTB(2,4)
      DATA ICHRTB(1,1),ICHRTB(2,1)/56,88/
      DATA ICHRTB(1,2),ICHRTB(2,2)/51,82/
      DATA ICHRTB(1,3),ICHRTB(2,3)/34,53/
      DATA ICHRTB(1,4),ICHRTB(2,4)/31,48/
      DATA ICODE(1)/27/
C * CHECK TERMINAL TYPE
      IF(KTERM .LE. 1)GO TO 10
      KSIZEF=K
      IF(K .LT. 1)KSIZEF=1
      IF(K .GT. 4)KSIZEF=4
      KHORSZ=ICHRTB(1,KSIZEF)
      KVERSZ=ICHRTB(2,KSIZEF)
      ICODE(2)=55+KSIZEF
      CALL TOUTST(2,ICODE)
10    RETURN
      END
C
C					subroutine  CZAXIS
C
      SUBROUTINE CZAXIS( ICODE )
	include 'pcplot.inc'
C * ICODE = 0 -- NORMAL Z AXIS
C *       = 1 --DEFOCUSED Z AXIS
C *       = 2 --WRITE-THRU ENABLE
      IF(KTERM .LE. 1)GO TO 10
      KZAXIS=ICODE
      IF(KZAXIS .LT. 0)KZAXIS=0
      IF(KZAXIS .GT. 2)KZAXIS=2
      CALL CWSEND
10    RETURN
      END
C
C					subroutine  CWSEND
C
      SUBROUTINE CWSEND
	include 'pcplot.inc'
      DIMENSION ICODE(2)
      DATA ICODE(1)/27/
      ICODE(2)=96+KZAXIS*8+KLINE
      CALL TOUTST(2,ICODE)
      RETURN
      END
*
*					subroutine  TSEND
*
	SUBROUTINE TSEND
	DIMENSION ITEMP(1)
	CALL BUFFPK( 0, ITEMP )
	RETURN
	END
*
*					SUBROUTINE  TOUTPT
*	Used for the output of one character.  Used for setting modes.
*
	SUBROUTINE TOUTPT( KKOUT )
	DIMENSION KOUT( 1 )
	KOUT( 1 ) = KKOUT
	CALL TOUTST( 1, KOUT )
	RETURN
	END
*
*					SUBROUTINE  TOUTST
*
      SUBROUTINE TOUTST( LEN, IADE )
*
*	LEN is the number of characters (plot 10 type ) to be 
*	output.   IADE contains the characters to be output.
*
	include 'pcplot.inc'

	DIMENSION IADE(*)
	LENOUT = LEN
	IF( LENOUT .GT. KACHAR ) LENOUT = KACHAR
	CALL BUFFPK( LENOUT,IADE )

	RETURN
	END
*
*					SUBROUTINE  PLTCHR
*
	SUBROUTINE PLTCHR( IX, IY, ICHAR )
	include 'pcplot.inc'

	DIMENSION ICHAR(*)
*
*	Calculates the 4010/4014 numbers corresponding to the given IX, IY
*	The order of the numbers is HIY, LSBYX, LOY, HIX, LOX
*
	KX = IX*KFACTR
	KY = IY*KFACTR
	IF( KX .LT. 0 ) KX = 0
	IF( KY .LT. 0 ) KY = 0
	ICHAR(1) = MOD( KY/128,32 ) + 32
	ICHAR(2) = MOD( KY,4 ) * 4  + MOD( KX,4 ) + 96
	ICHAR(3) = MOD( KY/4,32   ) + 96
	ICHAR(4) = MOD( KX/128,32 ) + 32
	ICHAR(5) = MOD( KX/4,32   ) + 64
	IF( KBAUDR .LT. 480 ) GO TO 11
	ITEMP = KPAD2-1
	IF( KTERM .LT. 2 ) GO TO 10
	ITEMP = IABS( KBEAMX-IX ) + IABS( KBEAMY-IY )
	ITEMP = ITEMP*KPAD2*KFACTR/8192 + 1
   10	KPADV = ITEMP
   11	CONTINUE
	RETURN
	END

	subroutine vtmode
C *
C *	This routine is used to exit 4010 emulation mode on the PC.
C *	One drawback of the PC emulators is that you have to redraw the
C *	graphics screen.
C *	If you go into VT220 mode to display a screen of text
C *
	call cwsend
	call toutpt( 7 )
	call toutpt( 7 )
	call toutpt( 7 )
	call tsend
	return
	end

